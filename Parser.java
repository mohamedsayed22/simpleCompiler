package compiler;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class Parser {
    
    /**
     * symbolTable: Holds the value of the symbol table generated by the Scanner 
     */
    private List<HashMap> symbolTable = new ArrayList<>();
    
    /**
     * syntaxTree: Holds the syntax tree which is the output of the Parser. 
     */
    
    private List<HashMap> syntaxTree = new ArrayList<>();
    
    /**
     * Keeps track of the current node index
     */
    private int nodeIndex;
    
    /**
     * Keeps track of the node index to use as parent for currently parsed node
     */
    private int lastParentIndex;
    
    
    /**
     * Parser Constructor.
     * ---------------------------------------------------------
     * 
     * 1- Accepts the symbolTable as parameter.
     * 2- Initializes the values of nodeIndex and lastParentIndex;
     * 3- Sets the value of symbol table
     * 4- Starts the recursive descent parsing operation
     * 
     * @param symbolTable 
     */
    public Parser(List<HashMap> symbolTable){
        
        this.nodeIndex = 0;
        this.lastParentIndex = -1;
        
        this.symbolTable = symbolTable;
        
        this.recursiveDescentParser();
    
    }
    
    /**
     * The recursive Descent parser
     * ------------------------------------
     * 
     * NB. It's a very important part to read about. I'm sure you'll be asked 
     * about it during you practical exam.
     * 
     * At First we need a grammar:
     * ---------------------------
     *
     * expression   -> number | operation expression
     * number       -> digit+
     * digit        -> 0|1|2|3|4|5|6|7|8|9
     * operation    -> mul|div|sum|sub
     * 
     * Then the parser loops through the tokens and builds nodes
     * All nodes must follow the grammar rules, Otherwise the parser throws an error.
     * 
     */
    private void recursiveDescentParser(){
        
        HashMap token;
        
        while( this.nodeIndex < this.symbolTable.size()){
            
            token = this.symbolTable.get( nodeIndex );
            
            this.parseExpression(token);
                   
        }
        
        System.out.println(this.syntaxTree);
         
    }
    
    
    /**
     * Checks against the token type, It must match one of expressions first words 
     * Either: number , or operation.
     * 
     * If an operation: it calls prseOperation method.
     * if a number: it calls parseNumber method.
     * else: Throws an error( Wrong Expression ). and exits the program.
     * 
     * @param token 
     */
    private void parseExpression(HashMap token){
        
        if( token.get("type") == "operation" ){
                
            this.parseOperation(token);
                
        }else if( token.get("type") == "number" ){
                
            this.parseNumber(token);
            
        }else{
                
            System.out.println("Error! Unknown expression!");
            System.exit( 0 );
        }
    
    }
      
    /**
     * We mean by the term parse is to get all data about the node.
     * Data is : type, value, and the parent.
     * 
     * As the grammar shows the operation must be followed by another expression,
     * so we check if it exists and send it to parsExpression method again, else
     * we throw an error message ( Operation needs operand (expression) ! )
     * 
     * It's pretty clear that each operation node is a parent of another node or more,
     * so it sets the lastParentIndex to its index.
     * 
     * @param token 
     */
    private void parseOperation(HashMap token){
        
        HashMap node, nextNode;
        node = new HashMap();
        
        // Sets type, value and parent
        node.put("type", token.get("type") );
        node.put("value", token.get("value") );
        node.put("parent", this.lastParentIndex );
        
        // Adds the node to the tree
        this.syntaxTree.add( node );
        
        // Makes it the parent of the next node because it's an operation
        this.lastParentIndex = this.nodeIndex;
        
        try{ // Parse the next node ( See the grammar )
            
            nextNode = this.symbolTable.get( ++this.nodeIndex );
            this.parseExpression( nextNode );
            
            
        }catch(IndexOutOfBoundsException e){
            
            System.out.println("Syntax error!, Operation needs operand (expression) !");
            System.exit( 0 );
            
        } 
          
    }
   
    /**
     * Gets the type and value of the number, then adds its node to the syntax tree.
     * 
     * As simple as that :)
     * 
     * 
     * @param token 
     */
    private void parseNumber(HashMap token){
        
        HashMap node;
        node = new HashMap();
        
        // Sets type, value and parent
        node.put("type", token.get("type") );
        node.put("value", token.get("value") );
        node.put( "parent", this.lastParentIndex );
        
        // Adds the node to the tree
        this.syntaxTree.add( node );
        
        this.nodeIndex ++;
     
    }
}
